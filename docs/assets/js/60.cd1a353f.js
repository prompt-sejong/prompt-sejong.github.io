(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{520:function(t,a,s){"use strict";s.r(a);var n=s(14),v=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"자바-스터디-6주차"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#자바-스터디-6주차"}},[t._v("#")]),t._v(" 자바 스터디 - 6주차")]),t._v(" "),a("h2",{attrs:{id:"자바-상속의-특징"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#자바-상속의-특징"}},[t._v("#")]),t._v(" 자바 상속의 특징")]),t._v(" "),a("p",[t._v("상속: 기존 클래스의 변수와 메소드를 물려받아 새로운 클래스 (확장될 수 있음) 을 의미함"),a("br"),t._v(" "),a("strong",[t._v("상속 →")]),t._v(" "),a("strong",[t._v("캡슐화, 추상화, 다형성")]),t._v("과 더불어 객체 지향 프로그래밍을 구성하는 특징 중 하나임"),a("br"),t._v("\n장점: 코드의 재사용성, 클래스 간의 계층적 분류 가능, 유지보수 용이")]),t._v(" "),a("h2",{attrs:{id:"상속-선언"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#상속-선언"}},[t._v("#")]),t._v(" 상속 선언")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" age"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("talk")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Hello World!"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" minji "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("badmintin")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"minton joa!"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("br"),t._v(" "),a("p",[t._v("Person 클래스를 상속받은 minji 클래스"),a("br"),t._v(" "),a("br"),t._v("\n부모 클래스: Person"),a("br"),t._v("\n자식 클래스: minji")]),t._v(" "),a("br"),t._v("\nminji는 Person 클래스가 가지고 있는 멤버 변수 (name, age)와 멤버 메소드(talk)를 모두 가지고 있음.   \n추가 기능으로 작성한 badminton 도 있음.  \n"),a("br"),t._v(" "),a("h2",{attrs:{id:"super-키워드"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#super-키워드"}},[t._v("#")]),t._v(" super 키워드")]),t._v(" "),a("p",[t._v("자신이 상속받은 "),a("code",[t._v("부모")]),t._v("를 가리키는 참조 변수임")]),t._v(" "),a("p",[t._v("자식 클래스가 부모 클래스의 property와 동일한 이름을 가지고 있다면"),a("br"),t._v("\n그것을 부모로부터 구분해낼 수 있어야 함")]),t._v(" "),a("p",[t._v("상속받을 때 부모 클래스의 멤버 변수, 함수는 모두 가져오는데 생성자는 가져오지 않음")]),t._v(" "),a("p",[t._v("⇒ 부모 클래스의 멤버를 초기화하기 위해서 부모 클래스의 생성자 또한 같이 호출해주어야 함."),a("br"),t._v("\n따라서 자식 클래스를 호출할 때 부모 클래스의 생성자도 동시에 호출하여야 함.")]),t._v(" "),a("p",[t._v("따라서 자식 클래스 생성자를 호출할 때, super()을 써주면 되는데 없다면 자바 컴파일러가 자동으로 추가해줌."),a("br"),t._v("\n하지만 부모 클래스의 생성자에 디폴트 생성자 형태가 아니고 매개변수를 갖는 생성자가 있다면, (생성자가 오버로딩 되면) 자동으로 추가되지 않음.")]),t._v(" "),a("p",[t._v("이에 따라 부모 클래스에 디폴트 생성자 형태로 매개변수가 없는 생성자를 추가해주거나,"),a("br"),t._v("\nsuper를 호출할 때 부모 클래스 생성자의 매개변수에 맞추어 호출해주면 됨.")]),t._v(" "),a("h2",{attrs:{id:"메소드-오버라이딩"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#메소드-오버라이딩"}},[t._v("#")]),t._v(" 메소드 오버라이딩")]),t._v(" "),a("p",[t._v("부모 클래스의 메소드를 자식 클래스에서 "),a("strong",[t._v("다시 정의")]),t._v("하는 것임")]),t._v(" "),a("p",[t._v("자바에서 자식 클래스는 부모 클래스의 private 멤버를 제외한 모든 메소드를 상속받음"),a("br"),t._v("\n상속받은 메소드는 그대로 사용해도 되고, 필요한 동작을 위해 재정의하여 사용할 수도 있음")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("오버라이딩 조건")])])]),t._v(" "),a("ol",[a("li",[t._v("오버라이딩은 메소드의 동작만을 재정의하는 것으로, "),a("strong",[t._v("메소드의 선언부는 기존 메소드와 완전히 같아야 함.")])]),t._v(" "),a("li",[t._v("부모 클래스의 메소드보다 "),a("strong",[t._v("더 좁은 범위의 접근 제어자로 변경할 수 없음.")])]),t._v(" "),a("li",[t._v("부모 클래스의 메소드보다 "),a("strong",[t._v("더 큰 범위의 예외를 선언할 수 없음.")])])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Parent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("display")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//부모 클래스의 메소드")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Child")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Parent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//메소드 오버라이딩")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("display")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//자식 클래스의 메소드")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"다이나믹-메소드-디스패치"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#다이나믹-메소드-디스패치"}},[t._v("#")]),t._v(" 다이나믹 메소드 디스패치")]),t._v(" "),a("p",[t._v("오버라이드 된 메소드에 대한 호출이 컴파일 타임이 아닌, 런타임에 결정되는 매커니즘")]),t._v(" "),a("p",[t._v("⇒ "),a("strong",[t._v("컴파일 타임:")]),t._v(" 컴파일러에 의해 수행되는 동작, 성공적으로 컴파일 되기 위해서 소스코드가 충족해야 하는 프로그래밍 언어 요구 사항, 또는 컴파일 동안 추론될 수 있는 프로그램의 속성을 나타냄.")]),t._v(" "),a("p",[t._v("자바에서는 자바 가상 머신을 말함.")]),t._v(" "),a("p",[t._v("기본적으로 컴파일은 소스코드를 기계가 이해할 수 있는 기계어로 바꿔주는 역할")]),t._v(" "),a("p",[t._v("그러나 자바 언어는 컴파일하면 바이트 코드가 생성됨. 이는 컴퓨터가 이해할 수 없고 JVM이 이해할 수 있는 언어임.")]),t._v(" "),a("p",[t._v("⇒ "),a("strong",[t._v("런타임:")]),t._v(" 컴퓨터 언어 안에 쓰인 프로그램을 관리하기 위해,"),a("br"),t._v("\n특정한 컴파일러나 가상 머신이 사용하는 기본 코드의 라이브러리나 프로그램을 통틀어"),a("br"),t._v(" "),a("code",[t._v("런타임 라이브러리")]),t._v(" 라고 말함.")]),t._v(" "),a("p",[t._v("런타임 에러: 프로그래머의 설계 미숙으로 프로그램 실행 중 발생하는 에러"),a("br"),t._v("\n(ex: NullPointerException, Infinite Loop, ArithmeticException)")]),t._v(" "),a("p",[t._v("컴파일 에러: 문법을 잘못 작성해 프로그램을 컴파일 할 수 없음"),a("br"),t._v("\n(ex: 세미콜론 누락, 괄호가 맞지 않음)")]),t._v(" "),a("h2",{attrs:{id:"추상-클래스"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#추상-클래스"}},[t._v("#")]),t._v(" 추상 클래스")]),t._v(" "),a("p",[t._v("추상 메소드: 자식 클래스에서 반드시 오버라이딩 해야만 사용할 수 있는 메소드"),a("br"),t._v(" "),a("br")]),t._v(" "),a("p",[t._v("추상 메소드를 사용하는 목적: 추상 메소드가 포함된 클래스를 상속받는 "),a("strong",[t._v("자식 클래스가 반드시 추상 메소드를 구현하도록 하기 위함")]),a("br"),t._v(" "),a("br"),t._v("\n이러한 추상 메소드는 선언부만이 존재하며 구현부는 작성되어 있지 않음"),a("br"),t._v("\n작성되어 있지 않은 구현부를 자식 클래스에서 오버라이딩 하여 사용함"),a("br"),t._v("\n자바에서 추상 메소드는 다음과 같은 문법으로 선언됨.")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("abstract")]),t._v(" 반환타입 메소드 이름"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("하나 이상의 추상 메소드를 포함하는 클래스를 가리켜 "),a("code",[t._v("추상 클래스(abstract class)")]),t._v("라고 부름\n"),a("br")]),t._v(" "),a("p",[t._v("추상 클래스는 다형성을 가지는 메소드의 집합을 정의할 수 있도록 함")]),t._v(" "),a("p",[t._v("⇒ 반드시 사용되어야 하는 메소드를 추상 클래스에 추상 메소드로 선언하면,"),a("br"),t._v("\n이 클래스를 상속받는 모든 클래스에서는 이 추상 메소드를 "),a("strong",[t._v("반드시")]),t._v(" 재정의해주어야 함")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("abstract")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" 클래스 이름"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("abstract")]),t._v(" 반환 타입 메소드 이름"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"final-키워드"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#final-키워드"}},[t._v("#")]),t._v(" final 키워드")]),t._v(" "),a("p",[t._v("⇒ 여러 컨텍스트에서 단 한번만 할당될 수 있는 entry를 정의할 때 사용됨\n"),a("br")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("final 변수")])]),t._v(" "),a("p",[t._v("⇒ "),a("strong",[t._v("원시타입:")]),t._v(" 로컬 원시 변수에 final로 선언하면 한번 초기화된 변수는 변경할 수 없는 상수값이 됨")]),t._v(" "),a("p",[t._v("⇒ "),a("strong",[t._v("객체 타입:")]),t._v(" 객체 변수에 final로 선언하면 그 변수에 다른 참조 값을 지정할 수 없음. 원시 타입과 동일하게 한번 쓰여진 변수는 재변경 불가함. 단, 객체 자체가 immutable하다는 의미는 아님. 객체의 속성은 변경 가능함.")]),t._v(" "),a("p",[t._v("⇒ "),a("strong",[t._v("메서드 인자:")]),t._v(" 메서드 인자에 final 키워드를 붙이면, 메서드 안에서 변수 값을 변경할 수 없음.")]),t._v(" "),a("p",[t._v("⇒ "),a("strong",[t._v("멤버 변수:")]),t._v(" 클래스의 멤버 변수에 final로 선언하면 상수값이 되거나 write-once 필드로 한번만 쓰이게 됨. final로 선언하면 초기화되는 시점은 생성자 메서드가 끝나기 전에 초기화됨. 하지만 static이냐 아니냐에 따라서 초기화 시점이 달라짐.")]),t._v(" "),a("ul",[a("li",[t._v("static final 멤버 변수 (static final int x = 1)\n"),a("ul",[a("li",[t._v("값과 함께 선언시")]),t._v(" "),a("li",[t._v("정적 초기화 블록에서 (static initialization block)")])])]),t._v(" "),a("li",[t._v("instance final 맴버 변수 (final int x = 1)\n"),a("ul",[a("li",[t._v("값과 함께 선언시")]),t._v(" "),a("li",[t._v("인스턴스 초기화 블록에서 (instance initialization block)")]),t._v(" "),a("li",[t._v("생성자 메서드에서")])])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("final 메서드")])]),t._v(" "),a("p",[t._v("메서드를 final로 선언하면 상속받은 클래스에서 오버라이드가 불가능해짐.")]),t._v(" "),a("p",[t._v("⇒ 구현한 코드의 변경을 원하지 않을 때 사용함. side-effect가 있으면 안되는 자바 코어 라이브러리에서 final로 선언된 부분을 볼 수 있음."),a("br"),t._v(" "),a("br")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("final 클래스")])]),t._v(" "),a("p",[t._v("클래스에 final을 선언하면 상속 자체가 안됨. 클래스 그대로 사용해야 함.  "),a("br"),t._v(" "),a("br")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("상수 클래스")])]),t._v(" "),a("p",[t._v("상수 값을 모아준 클래스")]),t._v(" "),a("p",[t._v("상수값을 모아준 클래스는 굳이 상속할 필요가 없음"),a("br"),t._v(" "),a("br")])])]),t._v(" "),a("h2",{attrs:{id:"object-클래스"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-클래스"}},[t._v("#")]),t._v(" Object 클래스")]),t._v(" "),a("p",[t._v("모든 자바 클래스의 "),a("strong",[t._v("조상 클래스")]),a("br"),t._v("\n모든 클래스는 Object 클래스의 모든 메소드를 바로 사용할 수 있음")]),t._v(" "),a("p",[t._v("이런 Object 클래스는 필드를 가지지 않음. "),a("code",[t._v("총 11개의 메소드")]),t._v(" 만으로 구성되어 있음"),a("br"),t._v(" "),a("br")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("toString() 메소드: 해당 인스턴스에 대한 정보를 문자열로 반환함. 클래스 이름과 함께 구분자로는 ‘@’가 사용되며, 그 뒤로 16진수 해시 코드가 추가됨. 16진수 해시 코드 값은 인스턴스의 주소를 가리킴.")])]),t._v(" "),a("li",[a("p",[t._v("equals() 메소드: 해당 인스턴스를 매개변수로 전달받는 참조 변수와 비교하여, 그 결과를 반환함. 이 때 참조 변수가 가리키는 값을 비교하므로 (주소 값) 서로 다른 두 객체는 언제나 false를 반환함.")])]),t._v(" "),a("li",[a("p",[t._v("clone() 메소드: 해당 인스턴스를 복제하여 새로운 인스턴스를 생성해 반환함. 단지 필드의 값을 복사하므로 필드의 값이 배열이나 인스턴스면 제대로 복제할 수 없음. 이런 경우 clone 메소드를 오버라이딩하여 복제가 제대로 이루어질 수 있도록 해야 함. 데이터 보호를 이유로 Cloneable 인터페이스를 구현한 클래스의 인스턴스만 사용이 가능함.")])])]),t._v(" "),a("br"),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("메소드")]),t._v(" "),a("th",[t._v("설명")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("protected Object clone()")]),t._v(" "),a("td",[t._v("해당 객체의 복제본을 생성하여 반환함.")])]),t._v(" "),a("tr",[a("td",[t._v("boolean equals(Object obj)")]),t._v(" "),a("td",[t._v("해당 객체와 전달받은 객체가 같은지 여부를 반환함.")])]),t._v(" "),a("tr",[a("td",[t._v("protected void finalize()")]),t._v(" "),a("td",[t._v("해당 객체를 더는 아무도 참조하지 않아 가비지 컬렉터가 객체의 리소스를 정리하기 위해 호출함.")])]),t._v(" "),a("tr",[a("td",[t._v("Class"),a("T",[t._v(" getClass()")])],1),t._v(" "),a("td",[t._v("해당 객체의 클래스 타입을 반환함.")])]),t._v(" "),a("tr",[a("td",[t._v("int hashCode()")]),t._v(" "),a("td",[t._v("해당 객체의 해시 코드값을 반환함.")])]),t._v(" "),a("tr",[a("td",[t._v("void notify()")]),t._v(" "),a("td",[t._v("해당 객체의 대기(wait)하고 있는 하나의 스레드를 다시 실행할 때 호출함.")])]),t._v(" "),a("tr",[a("td",[t._v("void notifyAll()")]),t._v(" "),a("td",[t._v("해당 객체의 대기(wait)하고 있는 모든 스레드를 다시 실행할 때 호출함.")])]),t._v(" "),a("tr",[a("td",[t._v("String toString()")]),t._v(" "),a("td",[t._v("해당 객체의 정보를 문자열로 반환함.")])]),t._v(" "),a("tr",[a("td",[t._v("void wait()")]),t._v(" "),a("td",[t._v("해당 객체의 다른 스레드가 notify()나 notifyAll() 메소드를 실행할 때까지 현재 스레드를 일시적으로 대기(wait)시킬 때 호출함.")])]),t._v(" "),a("tr",[a("td",[t._v("void wait(long timeout)")]),t._v(" "),a("td",[t._v("해당 객체의 다른 스레드가 notify()나 notifyAll() 메소드를 실행하거나 전달받은 시간이 지날 때까지 현재 스레드를 일시적으로 대기(wait)시킬 때 호출함.")])]),t._v(" "),a("tr",[a("td",[t._v("void wait(long timeout, int nanos)")]),t._v(" "),a("td",[t._v("해당 객체의 다른 스레드가 notify()나 notifyAll() 메소드를 실행하거나 전달받은 시간이 지나거나 다른 스레드가 현재 스레드를 인터럽트(interrupt) 할 때까지 현재 스레드를 일시적으로 대기(wait)시킬 때 호출함.")])])])])])}),[],!1,null,null,null);a.default=v.exports}}]);