---
sidebar: auto
---
# 자바 스터디 - 5주차
## 개요

**객체**(*Object*)란 속성과 동작으로 구성되어 있는 것으로, Java에서는 속성과 동작을 각각 **필드**(*Field*)와 메소드(*Method*)라고 부릅니다. 현실에서 사람이 혼자 행동하지 않고 서로가 상호 작용하며 살아가는 것처럼, 프로그램 속의 객체도 서로가 상호 작용하며 코드가 진행됩니다. 객체는 메소드를 통해 상호 작용하며, 이를 메소드 호출이라고 합니다. 

**클래스**(*class*)는 객체 생성을 위한 필드와 메소드의 정의가 포함됩니다. 따라서, 클래스는 객체를 만들기 위한 틀이라고 비유할 수 있습니다. 클래스로부터 만든 객체를 해당 클래스의 **인스턴스**(*instance*)라고 부르며, 클래스를 통해 객체를 만드는 것을 인스턴스화라고 합니다.

객체를 하나씩 조립해서 완성된 프로그램을 만드는 기법을 **객체 지향 프로그래밍**(*OOP: Object-Originated Programming*)이라고 부릅니다.

---

## 클래스 선언 및 객체 생성

### 클래스 선언

지금까지 사용한 모든 예제는 클래스였습니다. 클래스는 객체를 만들기 위한 틀이지만, 지금까지는 객체로 만들지 않고 main 메소드만 사용하여 코드 실행을 목적으로 클래스를 이용했습니다. 그러나, main 메소드가 없는 클래스는 객체 생성 과정을 거쳐 사용해야 합니다.

클래스는 **캐멀 케이스**(*Camel Case*)로 보통 작명됩니다. 캐멀 케이스란, 단어의 시작부분을 대문자로 표기하는 것입니다. HelloWorld, JavaClass와 같이 표기하는 것을 예시로 들 수 있습니다.

![](./assets/img1.png)


위와 같이 한 소스 파일에 클래스를 두 개 이상 선언할 수 있고, 이 경우 선언된 클래스의 개수만큼 바이트코드가 생성됩니다. 즉, 소스 파일은 클래스를 담고 있을뿐, 클래스 자체가 아닙니다. 위의 코드를 실행할 경우, MyClass.class와 MyClass2.class라는 두 개의 바이트코드가 생성됩니다.

하지만, public 접근 제어자는 소스 파일의 이름과 동일한 클래스에만 붙일 수 있으므로, 하나의 소스 파일에는 하나의 클래스만을 선언하는 것을 권장합니다.

### 객체 생성

객체를 생성하기 위해서는 우선 클래스를 선언해야 합니다. 클래스로부터 객체를 생성하려면, **new 연산자**를 사용해야 합니다. new 연산자 뒤에는 생성자가 와야 하는데, 여기서 생성된 객체는 메모리 힙(*heap*)에 생성됩니다. new 연산자를 사용하면, 해당 객체의 주솟값을 스택 영역에 반환(*return*)하며, 래퍼런스 변수와 같이 해당 주솟값을 참조하게 됩니다.

![](./assets/img2.png)

c1과 c2라는 객체가 생성되었습니다. c1과 c2는 MyClass 클래스의 인스턴스이고, new 연산자를 사용한만큼 객체가 메모리에 생성됩니다. 같은 공장에서 만들어진 두 개의 핸드폰이 서로 다르듯, 같은 클래스에서 생성된 두 개의 객체는 자신만의 고유한 정보를 가지면서 메모리에서 활동합니다. 요약하자면, MyClass 클래스로부터 만들어진 MyClass 객체는 heap 영역에 저장되고, stack 영역에 저장된 c1과 c2는 서로 다른 두 개의 MyClass 객체의 주솟값을 가지며, heap 영역에 있는 MyClass 객체를 참조합니다. 그리고, 둘은 같은 클래스로부터 만들어졌을지라도, 서로 완전 독립 관계입니다. 

![](./assets/img3.png)

클래스는 크게 **라이브러리 클래스**와 **실행 클래스**로 나뉩니다. 라이브러리 클래스는 다른 클래스에서 이용될 목적으로 설계되는 클래스고, 실행 클래스는 코드를 실행하기 위해 설계되는 클래스입니다. 실행 클래스는 실행 진입점인 main 메소드를 포함하고, 반드시 1개만 존재하여야 합니다.

위의 경우, MyClass.java는 라이브러리 클래스, CreatingObject.java는 실행 클래스가 됩니다. 실행 클래스 내에서도 라이브러리 클래스의 역할을 겸할 수 있습니다.

---

## 클래스의 구성 멤버

클래스는 객체에 포함되는 것을 정의합니다. 구성 멤버에는 크게 **필드**(*Field*), **생정자**(*Constructor*), **메소드**(*Method*)가 있습니다.

### 필드

필드는 객체의 고유한 정보를 저장하는 곳으로, **변수**(*Variable*)로 비유될 수 있습니다. 하지만, 필드와 변수는 다른 개념이며, 생성자 또는 메소드 내에서 선언과 소멸되는 변수와 달리, 필드는 객체 내에서 사용되며, 객체가 소멸하기 전까지 계속 존재한다는 차이점이 있습니다.

필드의 경우 클래스 내 어디서든 존재할 수 있지만, 예외적으로 생성자와 메소드의 내부에는 존재할 수 없습니다. 생성자와 메소드 내에 존재하는 것은 필드라고 부르지 않고, **지역 변수**(*Local Variable*)라고 부릅니다. 필드는 ‘클래스 멤버 변수’라고도 부르기도 합니다.

이는 프리미티브 타입(int, float, boolean 등)뿐만 아니라, 래퍼런스 타입(배열, 열거 등)으로도 사용할 수 있습니다. 필드는 따로 초기화를 하지 않는 경우, 기본값으로 자동 초기화합니다.

![](./assets/img4.png)

위와 같이 클래스 내부에서 필드를 호출하기 위해서는 기존 변수를 불러내는 방식과 동일하게, 필드명을 입력하여 호출할 수 있습니다. 실행 클래스가 아니므로, 코드가 실행되지 않습니다.

![](./assets/img5.png)

다른 클래스에서 FieldClass의 필드값을 가져오고 싶은 경우, 먼저 FieldClass 객체를 생성해야 합니다. 객체가 생성되기 전까지, 필드는 생성되지 않습니다.

필드 값을 호출하는 것은 위와 같이, ‘**객체 이름.필드 이름**’의 형태로 호출할 수 있습니다.

### 생성자

생성자는 클래스명과 동일한 메소드이며, 객체를 생성할 때 객체를 초기화하는 역할을 합니다. 생성자는 다른 메소드들과 달리 자료형이 없고, 리턴하는 것도 없습니다.

생성자는 new 연산자를 통해 클래스로부터 객체를 생성할 때 호출됩니다.

객체 초기화는, 필드를 초기화하거나 메소드를 호출하여 객체를 사용할 준비를 하는 것을 말하며, 생성자가 실행되면, 객체는 **heap 영역**에 생성되고 **stack 영역**에 그 객체의 주솟값을 저장하게 됩니다.

모든 클래스는 적어도 하나의 생성자를 가지고 있으며, 클래스 내에 생성자를 명시하지 않은 경우, **기본 생성자**(*Default Constructor*)가 바이트코드 내에 생성됩니다. 따라서, 직접 생성자를 명시하지 않아도 객체를 생성할 때 new 연산자 뒤에 생성자를 호출할 수 있습니다.

그러나, 클래스에 생성자를 하나라도 명시한 경우 기본 생성자가 생성되지 않습니다.

![](./assets/img6.png)

생성자를 선언할 때, a_, b_와 같이 매개변수 이름을 지은 이유는, 생성자(메소드)가 같은 이름의 변수를 호출할 때는 매개변수를 먼저 호출하기 때문에, 코드에 충돌이 있을 수 있기 때문입니다.

하지만, 코드가 길어질수록 간결한 것이 좋기 때문에 생성자의 매개변수 이름과 필드의 이름을 동일하게 하는 것을 권장합니다. 

충돌을 막기 위해, this를 사용하는데, this는 객체 자신의 참조를 의미합니다. this를 사용 경우, 이는 필드가 됩니다.

![](./assets/img7.png)

### this 참조

다음은 cpp에서 사용한 this 포인터 예시입니다.

![](./assets/img8.png)

C++과 Java는 this를 이용합니다. 이들은 모두 객체 자기 자신의 주솟값을 가리킨다는 공통점을 가지지만, 둘은 몇 가지 차이를 보입니다.

대표적으로, C++에서 this는 주솟값을 가리키는 **포인터**(*pointer*)이므로, **this 포인터**를 사용할 때는, 화살표(->)를 사용합니다. 그런 반면, Java에서의 this는 참조입니다.

![](./assets/img9.png)

![](./assets/img10.png)

C++에서는 메소드가 호출될 때, 객체로부터 주솟값을 넘겨받게 되는데, 이 값이 바로 this입니다. 우리가 보기엔, 객체를 포함하여, 객체 안에 속한 그 안에 있는 메소드들은 하나의 객체 안에 묶여있는 것처럼 보이지만, 실제로는 그렇게 동작하지 않습니다. 객체가 정의될 때, 객체가 메모리에 할당이 되고, 객체 안에 있는 메소드 또한, 메모리에 할당됩니다. 이때, 메소드는 객체가 할당된 주소가 아닌, 다른 주소에 할당되게 됩니다. 즉, 메모리상으로 메소드는 객체 안에 포함된 것이 아닌 것처럼 보일 수 있습니다. 그렇기 때문에, 멤버 메소드가 호출될 경우, 객체의 주솟값을 받게 되는 것입니다.

Java는 객체가 처음 생성될 때, 힙 영역에 객체를 저장하고, 스택 영역에는 객체를 참조할 수 있는 변수를 저장하게 됩니다. 하지만, 객체가 생성되기 이전에 처음으로 클래스가 참조될 때, **자바 가상 머신**(JVM)은 해당 클래스를 로딩하고, 클래스의 바이트코드가 메소드 영역에 저장됩니다. 메소드 영역에 저장된 메소드가 힙 영역에 저장된 객체를 this를 통해 참조하여 해당 인스턴스의 데이터에 접근할 수 있게 됩니다.

객체가 메소드를 호출할 때, 객체는 메소드 영역에 저장된 자신의 클래스에 정의된 메소드 코드를 사용하는데, 메소드는 힙 영역에 있는 객체의 데이터(필드)에 접근할 수 있으며, 이를 통해 객체의 상태를 읽거나 변경할 수 있게 됩니다. 메소드 내에서, this는 현재 객체를 가리키는 참조를 담당하며, 이를 통해 메소드는 실행 중인 객체의 필드에 접근하고, 객체의 다른 메소드를 호출할 수 있습니다.

### 생성자 오버로딩

C++에서는 매개변수만 다르다면, 함수명이 같아도 여러 개의 함수를 정의할 수 있습니다. 이를 오버로딩(overloading)이라고 합니다. Java도 마찬가지로, 생성자와 메소드를 오버로딩할 수 있으며, 오버로딩하려면 다음 중 하나의 조건을 만족해야 합니다.

1. 매개변수 자료형이 다름.
ex) void f (int a) / void f (double a)
2. 두 번째 매개변수의 자료형이 다름.
ex) void f (int a, int b) / void f (int a, double b)
3. 매개변수의 개수가 다름.
ex) void f (int a) / void f (int a, int b)
4. 매개변수의 종류는 같지만, 순서가 다름.
ex) void f (int a, double b) / void f (double a, int b)

그러나, 다음과 같은 조건인 경우 함수를 오버로딩할 수 없습니다. 

1. 매개변수의 이름이 다르지만, 자료형이 같음.
ex) void f (int a) / void f (int b)
2. return 타입이 다르지만, 매개변수의 자료형이 같음. 
ex) void f (int a) / int f (int a)
> 자료형이 다르면 오버로딩 가능.

외부로부터 제공되는 데이터에 의해 객체를 초기화할 때, 사용자가 일부 필드의 값만 입력할 수 있습니다. 이때, 이용하는 것이 오버로딩입니다.

![](./assets/img11.png)

위의 코드에서는 특정 필드값을 입력하지 않아도, 객체가 초기화될 수 있습니다.

![](./assets/img12.png)

오버로딩한 생성자가 많은 경우, 중복된 코드가 발생할 수 있습니다. 이때, 위와 같이 this() 코드를 사용하여, 다른 생성자 자체를 오버로딩할 수도 있습니다.

### 메소드

메소드는 객체의 동작을 의미하며, 다른 언어에서 **함수**(*function*)로 비유될 수 있습니다. 메소드는 자신의 필드값을 변경하는 역할을 할 뿐만 아니라, 다른 객체를 생성하여 다양한 상호 작용을 하는 수단이기도 합니다. 외부로부터 매개변수를 받아 실행에 이용하고, 그 결과를 외부로 반환할 수도 있습니다.

메소드 선언은 **선언부**(*Method Signature*)와 **실행 블록**으로 구성됩니다.

선언부에는 리턴 타입, 메소드 이름, 매개 변수 선언이 포함됩니다.

![](./assets/img13.png)

![](./assets/img14.png)

위와 같이 메소드를 선언하고 사용할 수 있습니다.

### 매개변수의 개수를 모를 경우의 메소드 선언

주어진 수의 합을 구하는 것과 같이, 메소드의 매개변수의 개수를 모를 경우, 매개변수를 배열 타입으로 선언하거나, …을 사용해서 선언할 수 있습니다.

![](./assets/img15.png)

![](./assets/img16.png)

매개변수를 배열 타입으로 선언할 경우 메소드를 호출하기 전에 배열을 생성해야 하지만, …을 사용할 경우, 따로 배열을 생성하지 않고 값만 전달하므로, 배열을 생성할 필요가 없다는 장점을 가지고 있습니다.

### 객체 내부에서의 메소드 호출

객체 내부에서 메소드를 호출할 경우, 메소드의 이름만 명시하면 됩니다.

### 메소드 오버로딩

메소드도 마찬가지로 생성자처럼 오버로딩할 수 있습니다.

![](./assets/img17.png)

위와 같이 자료형이 달라도 오버로딩을 통해 plus 메소드를 호출할 수 있습니다.

---

## 인스턴스 멤버와 정적 멤버

클래스 멤버란, 필드와 메소드를 통틀은 말입니다.

### 인스턴스 멤버

**인스턴스 멤버**는 객체마다 가지고 있는 멤버를 의미합니다. 지금까지 선언한 것과 같이 인스턴스 멤버를 선언할 수 있습니다.

### 정적 멤버 static

**정적 멤버**는 클래스에 고정된 멤버입니다. 정적 멤버는 객체를 생성하지 않고도 사용할 수 있습니다. 정적 멤버를 선언하는 방법은 다음과 같습니다.

![](./assets/img18.png)

정적 멤버를 호출할 경우, 인스턴스 멤버와 달리 객체를 별도 생성하지 않아도 호출할 수 있습니다. 정적 멤버는 **클래스 로더**(*Class Loader*)가 바이트 코드를 로딩할 때, 클래스별로 관리되기 때문입니다. 상수 또는 공통된 기능을 하는 메소드와 같이 객체마다 가지고 있을 필요가 없는 공통된 데이터라면, 정적 필드로 선언하는 것이 권장됩니다.

또한, 정적 멤버는 객체가 아닌 클래스에 속한 것이기 때문에, 객체 자신의 참조를 의미하는 this 키워드를 통해 호출할 수 없습니다. 그리고, 정적 메소드 내에서 인스턴스 변수를 사용하려면, 메소드 내에 객체를 별도로 생성하여야 합니다.

![](./assets/img19.png)

### 싱글톤

전체 프로그램에서 단 하나의 객체만을 만들도록 보장해야 하는 경우가 있는데, 이 객체를 **싱글톤**(*Singleton*)이라고 부릅니다. 싱글톤은 클래스 외부에서 new 연산자를 통해 생성자를 호출하는 것을 막아야하므로, 생성자 앞에 private 접근 제어자를 붙입니다. 자신의 정적 필드를 통해 생성자를 호출하여 객체를 생성해 초기화하고, 외부 클래스에서의 접근을 막을 수 있습니다. 외부에서 호출하고 싶다면, 정적 메소드 **getInstance()**를 통해, 객체를 호출할 수 있습니다.

![](./assets/img20.png)

getInstance() 메소드는 단 하나의 객체만 반환하므로, st1과 st2는 동일한 객체를 참조합니다.

### final 필드와 상수

**final 필드**는 최종적인 필드라는 뜻으로, final 필드는 초기값이 저장되면 그 값이 최종값이 되어 프로그램 실행 중 수정이 불가능해집니다. final 필드는 처음 선언시에 초기화를 할 수 있고, 생성자를 통해 초기화할 수 있습니다.

또한, 앞에 static을 붙이면 **상수**(*static final*)가 되며, 이는 불변의 값이자 범용성을 띄기 때문에 static을 붙입니다. 상수는 이름을 모두 대문자로 작성하는 관례가 있습니다. 두 개 이상의 단어로 구성된 경우 언더바(_)를 통해 연결합니다.

![](./assets/img21.png)

---

## 패키지와 접근 제어자

### 패키지

패키지는 표면적으로 디렉토리(폴더)와 같은 역할을 합니다. 패키지는 클래스를 유일하게 만들어주는 기능을 하며, 이는 같은 이름의 패키지가 있더라도, 이들을 구분짓게 해주는 역할을 합니다. 

![](./assets/img22.png)

위 클래스의 전체 이름은 WEEK01.HelloWorld가 되며, 패키지 위에 상위 패키지가 있는 경우 그 사이에 점(.)을 사용합니다.

사용하고자 하는 클래스가 다른 패키지에 있는 경우 **import문**을 이용하며, 이는 **package문**과 동일하게 이용할 수 있습니다. 이때, ‘*****’는 해당 패키지에 소속된 모든 클래스를 사용할 것임을 알리는 의미입니다.

### 접근 제어자

**접근 제어자**(*Access Modifier*)는 클래스, 필드, 메소드 등의 멤버 접근 제어를 담당합니다. 접근 제어자는 public, protected, private로 나뉘고, 이 세 개에 다 해당하지 않은 경우, default 접근 제어를 가집니다.

**public 접근 제어자**는 외부 클래스가 자유롭게 사용할 수 있도록 합니다.

**protected 접근 제어자**는 같은 패키지 또는 자식 클래스에서 사용할 수 있도록 합니다.

**private 접근 제어자**는 클래스 내부에서만 사용할 수 있도록 합니다.

**default 접근 제어자**는 같은 패키지에 소속된 클래스에서만 사용할 수 있도록 합니다.

![](./assets/img23.png)

![](./assets/img24.png)

AccessModifier의 객체는 두 필드 input1, input2는 private이고, 두 값의 합을 구하는 메소드도 private이므로, 외부 클래스(main)에서는 접근할 수 없습니다. 하지만, protected인  modifyInputs 메소드와 public인 printResult() 메소드를 통해 private 멤버에 접근할 수 있습니다.

### getter과 setter 메소드

객체의 필드는 객체 외부에서 직접적으로 접근하는 것을 막는 경우가 많은데, 이는 객체의 무결성*(*Integrity*)이 훼손될 수 있기 때문입니다. 예를 들어, 두 변의 길이가 주어진 직사각형의 넓이를 구하는 프로그램을 만드려고 할 때, 필드에 직접 값을 입력하게 한다면, 사용자가 음수를 넣을 수도 있습니다. 이때, 필드의 수정을 막는 방법은 필드를 private로, 이를 수정할 수 있는 메소드는 public으로 두는 것입니다. 이렇게 될 경우, 객체 외부에서 객체의 필드를 수정하려면 메소드를 통해 접근할 수 밖에 없게 됩니다.

**setter 메소드**는 매개값을 검증해서 유효한 값만 객체의 필드에 접근할 수 있게 하는 역할을 합니다.

**getter 메소드**는 필드값을 가공한 후 외부로 전달하는 역할을 합니다.  

![](./assets/img25.png)

GetterSetter 내의 필드는 모두 private이므로, 외부 클래스에서 필드의 값을 직접 수정할 수 없습니다. 수정하고 싶으면 public인 setInput 메소드를 통해 객체 내의 필드값을 수정할 수 있습니다.

 

무결성*: 신뢰할 수 있는 서비스 제공을 위해서 의도하지 않은 요인에 의해 데이터, 소프트웨어, 시스템 등이 변경되거나 손상되지 않고 완전성, 정확성, 일관성을 유지함을 보장하는 특성.