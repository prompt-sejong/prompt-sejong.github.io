---
sidebar: auto
---
# 자바 스터디 - 6주차
## 자바 상속의 특징

상속: 기존 클래스의 변수와 메소드를 물려받아 새로운 클래스 (확장될 수 있음) 을 의미함  
**상속 →** **캡슐화, 추상화, 다형성**과 더불어 객체 지향 프로그래밍을 구성하는 특징 중 하나임  
장점: 코드의 재사용성, 클래스 간의 계층적 분류 가능, 유지보수 용이  

## 상속 선언

```java
public class Person{
	String name;
	int age;
	
	public void talk(){
		System.out.println("Hello World!");
	}
}
```

```java
public class minji extends Person{
	public void badmintin(){
		System.out.println("minton joa!");
	}
}

```

<br>

Person 클래스를 상속받은 minji 클래스  
<br>
부모 클래스: Person  
자식 클래스: minji   

<br>
minji는 Person 클래스가 가지고 있는 멤버 변수 (name, age)와 멤버 메소드(talk)를 모두 가지고 있음.   
추가 기능으로 작성한 badminton 도 있음.  
<br>

## super 키워드

자신이 상속받은 `부모`를 가리키는 참조 변수임  

자식 클래스가 부모 클래스의 property와 동일한 이름을 가지고 있다면  
그것을 부모로부터 구분해낼 수 있어야 함  

상속받을 때 부모 클래스의 멤버 변수, 함수는 모두 가져오는데 생성자는 가져오지 않음  

⇒ 부모 클래스의 멤버를 초기화하기 위해서 부모 클래스의 생성자 또한 같이 호출해주어야 함.   
따라서 자식 클래스를 호출할 때 부모 클래스의 생성자도 동시에 호출하여야 함.  

따라서 자식 클래스 생성자를 호출할 때, super()을 써주면 되는데 없다면 자바 컴파일러가 자동으로 추가해줌.   
하지만 부모 클래스의 생성자에 디폴트 생성자 형태가 아니고 매개변수를 갖는 생성자가 있다면, (생성자가 오버로딩 되면) 자동으로 추가되지 않음.  

이에 따라 부모 클래스에 디폴트 생성자 형태로 매개변수가 없는 생성자를 추가해주거나,   
super를 호출할 때 부모 클래스 생성자의 매개변수에 맞추어 호출해주면 됨.  

## 메소드 오버라이딩

부모 클래스의 메소드를 자식 클래스에서 **다시 정의**하는 것임

자바에서 자식 클래스는 부모 클래스의 private 멤버를 제외한 모든 메소드를 상속받음  
상속받은 메소드는 그대로 사용해도 되고, 필요한 동작을 위해 재정의하여 사용할 수도 있음  

- **오버라이딩 조건**  
1. 오버라이딩은 메소드의 동작만을 재정의하는 것으로, **메소드의 선언부는 기존 메소드와 완전히 같아야 함.**  
2. 부모 클래스의 메소드보다 **더 좁은 범위의 접근 제어자로 변경할 수 없음.**  
3. 부모 클래스의 메소드보다 **더 큰 범위의 예외를 선언할 수 없음.**  

```java
class Parent{
	void display(){ //부모 클래스의 메소드
	}
	
}

class Child extends Parent{
	//메소드 오버라이딩
	void display(){ //자식 클래스의 메소드
	}
}
```


## 다이나믹 메소드 디스패치

오버라이드 된 메소드에 대한 호출이 컴파일 타임이 아닌, 런타임에 결정되는 매커니즘  

⇒ **컴파일 타임:** 컴파일러에 의해 수행되는 동작, 성공적으로 컴파일 되기 위해서 소스코드가 충족해야 하는 프로그래밍 언어 요구 사항, 또는 컴파일 동안 추론될 수 있는 프로그램의 속성을 나타냄.  

자바에서는 자바 가상 머신을 말함.  

기본적으로 컴파일은 소스코드를 기계가 이해할 수 있는 기계어로 바꿔주는 역할  

그러나 자바 언어는 컴파일하면 바이트 코드가 생성됨. 이는 컴퓨터가 이해할 수 없고 JVM이 이해할 수 있는 언어임.  

⇒ **런타임:** 컴퓨터 언어 안에 쓰인 프로그램을 관리하기 위해,   
특정한 컴파일러나 가상 머신이 사용하는 기본 코드의 라이브러리나 프로그램을 통틀어  
`런타임 라이브러리` 라고 말함.  

런타임 에러: 프로그래머의 설계 미숙으로 프로그램 실행 중 발생하는 에러   
(ex: NullPointerException, Infinite Loop, ArithmeticException)    

컴파일 에러: 문법을 잘못 작성해 프로그램을 컴파일 할 수 없음  
(ex: 세미콜론 누락, 괄호가 맞지 않음)    

## 추상 클래스  

추상 메소드: 자식 클래스에서 반드시 오버라이딩 해야만 사용할 수 있는 메소드  
<br>

추상 메소드를 사용하는 목적: 추상 메소드가 포함된 클래스를 상속받는 **자식 클래스가 반드시 추상 메소드를 구현하도록 하기 위함**  
<br>
이러한 추상 메소드는 선언부만이 존재하며 구현부는 작성되어 있지 않음  
작성되어 있지 않은 구현부를 자식 클래스에서 오버라이딩 하여 사용함  
자바에서 추상 메소드는 다음과 같은 문법으로 선언됨.  

```java
abstract 반환타입 메소드 이름();
```

하나 이상의 추상 메소드를 포함하는 클래스를 가리켜 `추상 클래스(abstract class)`라고 부름
<br>

추상 클래스는 다형성을 가지는 메소드의 집합을 정의할 수 있도록 함  
 
⇒ 반드시 사용되어야 하는 메소드를 추상 클래스에 추상 메소드로 선언하면,   
이 클래스를 상속받는 모든 클래스에서는 이 추상 메소드를 **반드시** 재정의해주어야 함   

```java
abstract class 클래스 이름{

    abstract 반환 타입 메소드 이름();

}
```

## final 키워드

⇒ 여러 컨텍스트에서 단 한번만 할당될 수 있는 entry를 정의할 때 사용됨
<br>

- **final 변수**

    ⇒ **원시타입:** 로컬 원시 변수에 final로 선언하면 한번 초기화된 변수는 변경할 수 없는 상수값이 됨  

    ⇒ **객체 타입:** 객체 변수에 final로 선언하면 그 변수에 다른 참조 값을 지정할 수 없음. 원시 타입과 동일하게 한번 쓰여진 변수는 재변경 불가함. 단, 객체 자체가 immutable하다는 의미는 아님. 객체의 속성은 변경 가능함.  

    ⇒ **메서드 인자:** 메서드 인자에 final 키워드를 붙이면, 메서드 안에서 변수 값을 변경할 수 없음.  

    ⇒ **멤버 변수:** 클래스의 멤버 변수에 final로 선언하면 상수값이 되거나 write-once 필드로 한번만 쓰이게 됨. final로 선언하면 초기화되는 시점은 생성자 메서드가 끝나기 전에 초기화됨. 하지만 static이냐 아니냐에 따라서 초기화 시점이 달라짐.  

    - static final 멤버 변수 (static final int x = 1)
        - 값과 함께 선언시
        - 정적 초기화 블록에서 (static initialization block)
    - instance final 맴버 변수 (final int x = 1)
        - 값과 함께 선언시
        - 인스턴스 초기화 블록에서 (instance initialization block)
        - 생성자 메서드에서

- **final 메서드**  

    메서드를 final로 선언하면 상속받은 클래스에서 오버라이드가 불가능해짐.   

    ⇒ 구현한 코드의 변경을 원하지 않을 때 사용함. side-effect가 있으면 안되는 자바 코어 라이브러리에서 final로 선언된 부분을 볼 수 있음.  
    <br>

- **final 클래스**

    클래스에 final을 선언하면 상속 자체가 안됨. 클래스 그대로 사용해야 함.  \
    <br>

- **상수 클래스**

    상수 값을 모아준 클래스

    상수값을 모아준 클래스는 굳이 상속할 필요가 없음  
    <br>  



## Object 클래스
  
모든 자바 클래스의 **조상 클래스**  
모든 클래스는 Object 클래스의 모든 메소드를 바로 사용할 수 있음  

이런 Object 클래스는 필드를 가지지 않음. `총 11개의 메소드` 만으로 구성되어 있음  
<br>

1. toString() 메소드: 해당 인스턴스에 대한 정보를 문자열로 반환함. 클래스 이름과 함께 구분자로는 ‘@’가 사용되며, 그 뒤로 16진수 해시 코드가 추가됨. 16진수 해시 코드 값은 인스턴스의 주소를 가리킴.   
   
2. equals() 메소드: 해당 인스턴스를 매개변수로 전달받는 참조 변수와 비교하여, 그 결과를 반환함. 이 때 참조 변수가 가리키는 값을 비교하므로 (주소 값) 서로 다른 두 객체는 언제나 false를 반환함.  
   
3. clone() 메소드: 해당 인스턴스를 복제하여 새로운 인스턴스를 생성해 반환함. 단지 필드의 값을 복사하므로 필드의 값이 배열이나 인스턴스면 제대로 복제할 수 없음. 이런 경우 clone 메소드를 오버라이딩하여 복제가 제대로 이루어질 수 있도록 해야 함. 데이터 보호를 이유로 Cloneable 인터페이스를 구현한 클래스의 인스턴스만 사용이 가능함. 

 
 <br>



| 메소드                             | 설명                                                                                                                                                                                                       |
| ---------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| protected Object clone()           | 해당 객체의 복제본을 생성하여 반환함.                                                                                                                                                                      |
| boolean equals(Object obj)         | 해당 객체와 전달받은 객체가 같은지 여부를 반환함.                                                                                                                                                          |
| protected void finalize()          | 해당 객체를 더는 아무도 참조하지 않아 가비지 컬렉터가 객체의 리소스를 정리하기 위해 호출함.                                                                                                                |
| Class<T> getClass()                | 해당 객체의 클래스 타입을 반환함.                                                                                                                                                                          |
| int hashCode()                     | 해당 객체의 해시 코드값을 반환함.                                                                                                                                                                          |
| void notify()                      | 해당 객체의 대기(wait)하고 있는 하나의 스레드를 다시 실행할 때 호출함.                                                                                                                                     |
| void notifyAll()                   | 해당 객체의 대기(wait)하고 있는 모든 스레드를 다시 실행할 때 호출함.                                                                                                                                       |
| String toString()                  | 해당 객체의 정보를 문자열로 반환함.                                                                                                                                                                        |
| void wait()                        | 해당 객체의 다른 스레드가 notify()나 notifyAll() 메소드를 실행할 때까지 현재 스레드를 일시적으로 대기(wait)시킬 때 호출함.                                                                                 |
| void wait(long timeout)            | 해당 객체의 다른 스레드가 notify()나 notifyAll() 메소드를 실행하거나 전달받은 시간이 지날 때까지 현재 스레드를 일시적으로 대기(wait)시킬 때 호출함.                                                        |
| void wait(long timeout, int nanos) | 해당 객체의 다른 스레드가 notify()나 notifyAll() 메소드를 실행하거나 전달받은 시간이 지나거나 다른 스레드가 현재 스레드를 인터럽트(interrupt) 할 때까지 현재 스레드를 일시적으로 대기(wait)시킬 때 호출함. |
